import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, BehaviorSubject } from 'rxjs';
import { environment } from '../../environments/environment';

/**
 * UNILEVEL SERVICE - Based on "Reglas del Plan Unilevel" diagram
 * 
 * Este servicio maneja la lógica del sistema de niveles unilevel:
 * 1. Reglas de niveles (Bronce, Plata, Oro, Platino)
 * 2. Cálculo de comisiones por nivel
 * 3. Avance de nivel automático basado en inversiones
 * 4. Búsqueda de patrocinador en el nivel actual
 * 5. Inicio de nueva inversión generada desde el sistema
 */

export type UnilevelLevel = 'BRONCE' | 'PLATA' | 'ORO' | 'PLATINO';

export interface UnilevelLevelRules {
  level: UnilevelLevel;
  rangeMin: number;
  rangeMax: number;
  networkLevels: number; // Niveles 1-2, 1-5, 1-8, 1-10
  topAmount: number; // $50, $750, $2500, $5000+
  color: string;
  description: string;
}

export interface UnilevelMember {
  userId: string;
  email: string;
  firstName: string;
  lastName: string;
  sponsorId: string;
  currentLevel: UnilevelLevel;
  networkLevel: number; // Position in the tree (1-10)
  totalInvested: number;
  joinDate: Date;
  isActive: boolean;
}

export interface NetworkTree {
  user: UnilevelMember;
  children: NetworkTree[];
  level: number;
  totalMembers: number;
}

export interface LevelAdvancement {
  userId: string;
  previousLevel: UnilevelLevel;
  newLevel: UnilevelLevel;
  totalInvested: number;
  advancementDate: Date;
  autoGenerated: boolean;
  message: string;
}

export interface CommissionCalculation {
  userId: string;
  level: UnilevelLevel;
  networkLevel: number;
  amount: number;
  percentage: number;
  totalCommission: number;
  fromUserId: string;
}

@Injectable({
  providedIn: 'root'
})
export class UnilevelService {
  private apiUrl = `${environment.apiUrl}/unilevel`;
  private currentUserLevel$ = new BehaviorSubject<UnilevelLevel>('BRONCE');

  // Level rules based on diagram
  private levelRules: Record<UnilevelLevel, UnilevelLevelRules> = {
    BRONCE: {
      level: 'BRONCE',
      rangeMin: 10,
      rangeMax: 99,
      networkLevels: 2, // Niveles 1-2
      topAmount: 50,
      color: '#CD7F32',
      description: 'Nivel inicial con red de 2 niveles'
    },
    PLATA: {
      level: 'PLATA',
      rangeMin: 100,
      rangeMax: 999,
      networkLevels: 5, // Niveles 1-5
      topAmount: 750,
      color: '#C0C0C0',
      description: 'Nivel intermedio con red de 5 niveles'
    },
    ORO: {
      level: 'ORO',
      rangeMin: 1000,
      rangeMax: 4999,
      networkLevels: 8, // Niveles 1-8
      topAmount: 2500,
      color: '#FFD700',
      description: 'Nivel avanzado con red de 8 niveles'
    },
    PLATINO: {
      level: 'PLATINO',
      rangeMin: 5000,
      rangeMax: 999999,
      networkLevels: 10, // Niveles 1-10
      topAmount: 5000,
      color: '#E5E4E2',
      description: 'Nivel máximo con red de 10 niveles'
    }
  };

  constructor(private http: HttpClient) {}

  /**
   * Get level rules for specific level
   */
  getLevelRules(level: UnilevelLevel): UnilevelLevelRules {
    return this.levelRules[level];
  }

  /**
   * Get all level rules
   */
  getAllLevelRules(): UnilevelLevelRules[] {
    return Object.values(this.levelRules);
  }

  /**
   * STEP 1: Determine level based on investment range
   * Based on diagram: "¿Su Rango cubre este Nivel?"
   */
  determineLevel(totalInvested: number): UnilevelLevel {
    if (totalInvested >= 5000) {
      return 'PLATINO';
    } else if (totalInvested >= 1000) {
      return 'ORO';
    } else if (totalInvested >= 100) {
      return 'PLATA';
    } else {
      return 'BRONCE';
    }
  }

  /**
   * STEP 2: Check if user's range covers this level
   * Based on diagram: "¿Su Rango cubre este Nivel?"
   */
  doesRangeCoverLevel(userLevel: UnilevelLevel, targetNetworkLevel: number): boolean {
    const rules = this.levelRules[userLevel];
    return targetNetworkLevel <= rules.networkLevels;
  }

  /**
   * STEP 3: Check if user exceeds monthly top
   * Based on diagram: "¿Ya superó su Tope Mensual?"
   */
  hasExceededMonthlyTop(userId: string, currentMonth: Date): Observable<boolean> {
    return this.http.get<boolean>(
      `${this.apiUrl}/user/${userId}/exceeded-top?month=${currentMonth.toISOString()}`
    );
  }

  /**
   * STEP 4: Calculate and pay commission
   * Based on diagram: "Calcular % y Pagar Comisión"
   */
  calculateCommission(
    sponsorLevel: UnilevelLevel,
    networkLevel: number,
    investmentAmount: number
  ): CommissionCalculation | null {
    const rules = this.levelRules[sponsorLevel];
    
    // Check if network level is within sponsor's range
    if (networkLevel > rules.networkLevels) {
      return null;
    }

    // Commission percentages by network level (example, adjust as needed)
    const commissionPercentages: Record<number, number> = {
      1: 10, // 10% for direct referrals (level 1)
      2: 5,  // 5% for level 2
      3: 3,  // 3% for level 3
      4: 2,  // 2% for level 4
      5: 2,  // 2% for level 5
      6: 1,  // 1% for level 6
      7: 1,  // 1% for level 7
      8: 1,  // 1% for level 8
      9: 0.5,  // 0.5% for level 9
      10: 0.5  // 0.5% for level 10
    };

    const percentage = commissionPercentages[networkLevel] || 0;
    const commission = (investmentAmount * percentage) / 100;

    return {
      userId: '',
      level: sponsorLevel,
      networkLevel,
      amount: investmentAmount,
      percentage,
      totalCommission: commission,
      fromUserId: ''
    };
  }

  /**
   * STEP 5: User reaches insufficient range
   * Based on diagram: "No Pagar: Rango Insuficiente"
   */
  notifyInsufficientRange(userId: string, targetLevel: number): { message: string; action: string } {
    return {
      message: `Tu nivel actual no cubre el nivel ${targetLevel} de la red`,
      action: 'Aumenta tu inversión para desbloquear más niveles y ganar comisiones'
    };
  }

  /**
   * STEP 6: User exceeds monthly top
   * Based on diagram: "No Pagar: Tope Alcanzado"
   */
  notifyTopReached(userId: string, topAmount: number): { message: string; action: string } {
    return {
      message: `Has alcanzado tu tope mensual de $${topAmount}`,
      action: 'Las comisiones adicionales se acumularán para el próximo mes'
    };
  }

  /**
   * STEP 7: Check if user's current level is less than 10
   * Based on diagram: "¿Nivel Actual < 10?"
   */
  isLevelBelowMax(currentNetworkLevel: number): boolean {
    return currentNetworkLevel < 10;
  }

  /**
   * STEP 8: Search for sponsor in current level
   * Based on diagram: "Buscar Patrocinador en Nivel Actual"
   */
  findSponsorInCurrentLevel(userId: string, currentLevel: number): Observable<UnilevelMember | null> {
    return this.http.get<UnilevelMember | null>(
      `${this.apiUrl}/user/${userId}/sponsor-in-level/${currentLevel}`
    );
  }

  /**
   * STEP 9: Check if sponsor exists at this level
   * Based on diagram: "¿Existe Usuario en este nivel?"
   */
  sponsorExistsAtLevel(sponsor: UnilevelMember | null): boolean {
    return sponsor !== null;
  }

  /**
   * STEP 10: Advance to next level
   * Based on diagram: "Siguiente Nivel: Nivel = Nivel + 1"
   */
  advanceToNextLevel(currentLevel: number): number {
    return currentLevel + 1;
  }

  /**
   * STEP 11: Initialize new investment
   * Based on diagram: "Iniciar Variable: Nivel Actual = 1"
   */
  initializeNewInvestment(userId: string): { level: number; message: string } {
    return {
      level: 1,
      message: 'Nueva inversión generada, iniciando en nivel 1'
    };
  }

  /**
   * STEP 12: End process when no more sponsors found
   * Based on diagram: "Fin del Proceso (Fin de la cadena)"
   */
  endOfChain(): { message: string } {
    return {
      message: 'Se llegó al final de la cadena de patrocinadores'
    };
  }

  /**
   * Get user's network tree
   */
  getUserNetworkTree(userId: string, maxDepth: number = 10): Observable<NetworkTree> {
    return this.http.get<NetworkTree>(
      `${this.apiUrl}/user/${userId}/network-tree?depth=${maxDepth}`
    );
  }

  /**
   * Get all members in user's network
   */
  getUserNetwork(userId: string): Observable<UnilevelMember[]> {
    return this.http.get<UnilevelMember[]>(`${this.apiUrl}/user/${userId}/network`);
  }

  /**
   * Check if user can advance to next level
   */
  canAdvanceToLevel(userId: string, targetLevel: UnilevelLevel): Observable<boolean> {
    return this.http.get<boolean>(
      `${this.apiUrl}/user/${userId}/can-advance/${targetLevel}`
    );
  }

  /**
   * Process level advancement
   */
  processLevelAdvancement(userId: string, newTotalInvested: number): Observable<LevelAdvancement> {
    return this.http.post<LevelAdvancement>(`${this.apiUrl}/user/${userId}/advance-level`, {
      newTotalInvested
    });
  }

  /**
   * Get user's monthly commission summary
   */
  getMonthlyCommissionSummary(userId: string, month: Date): Observable<any> {
    return this.http.get(
      `${this.apiUrl}/user/${userId}/commission-summary?month=${month.toISOString()}`
    );
  }

  /**
   * Get user's current level info
   */
  getUserLevelInfo(userId: string): Observable<{
    level: UnilevelLevel;
    totalInvested: number;
    networkCount: number;
    monthlyEarnings: number;
    topReached: boolean;
  }> {
    return this.http.get<any>(`${this.apiUrl}/user/${userId}/level-info`);
  }

  /**
   * Distribute commission through network
   * This is the main method that implements the full diagram flow
   */
  distributeCommission(
    fromUserId: string,
    investmentAmount: number,
    sponsorChain: string[]
  ): Observable<CommissionCalculation[]> {
    return this.http.post<CommissionCalculation[]>(`${this.apiUrl}/distribute-commission`, {
      fromUserId,
      investmentAmount,
      sponsorChain
    });
  }

  /**
   * Get commission history
   */
  getCommissionHistory(
    userId: string,
    startDate?: Date,
    endDate?: Date
  ): Observable<CommissionCalculation[]> {
    let url = `${this.apiUrl}/user/${userId}/commission-history`;
    const params: string[] = [];
    
    if (startDate) {
      params.push(`startDate=${startDate.toISOString()}`);
    }
    if (endDate) {
      params.push(`endDate=${endDate.toISOString()}`);
    }
    
    if (params.length > 0) {
      url += `?${params.join('&')}`;
    }
    
    return this.http.get<CommissionCalculation[]>(url);
  }
}
